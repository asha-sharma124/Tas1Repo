name: Single Instance Blue-Green Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  BLUE_TG_ARN: ${{ secrets.BLUE_TARGET_GROUP_ARN }}
  GREEN_TG_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
  ALB_LISTENER_ARN: ${{ secrets.ALB_LISTENER_ARN }}
  LAUNCH_TEMPLATE_ID: ${{ secrets.LAUNCH_TEMPLATE_ID }}
  PRIVATE_SUBNET_ID: ${{ secrets.PRIVATE_SUBNET_ID }}

jobs:
  build:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set image tag
        id: set_tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tag=v${{ github.run_number }}-${SHORT_SHA}" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Database image
        uses: docker/build-push-action@v4
        with:
          context: ./db
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-db:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-db:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-db:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-db:buildcache,mode=max
      
      - name: Build and push API image
        uses: docker/build-push-action@v4
        with:
          context: ./api
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-api:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-api:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-api:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-api:buildcache,mode=max
      
      - name: Build and push Frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./app
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-frontend:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-frontend:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-frontend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-frontend:buildcache,mode=max
      
      - name: Upload deployment files to S3
        run: |
          # Update docker-compose.yml with image references
          sed -i "s|build: ./db|image: ${{ secrets.DOCKER_USERNAME }}/quotes-db:${{ steps.set_tag.outputs.tag }}|g" docker-compose.yml
          sed -i "s|build: ./api|image: ${{ secrets.DOCKER_USERNAME }}/quotes-api:${{ steps.set_tag.outputs.tag }}|g" docker-compose.yml
          sed -i "s|build: ./app|image: ${{ secrets.DOCKER_USERNAME }}/quotes-frontend:${{ steps.set_tag.outputs.tag }}|g" docker-compose.yml
          
          # Upload all deployment files
          aws s3 cp docker-compose.yml s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ steps.set_tag.outputs.tag }}/
          aws s3 cp nginx-config/ s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ steps.set_tag.outputs.tag }}/nginx-config/ --recursive
          aws s3 cp deployment/ s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ steps.set_tag.outputs.tag }}/deployment/ --recursive
          
          echo "‚úÖ Deployment files uploaded to S3"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}

  provision-green:
    name: Launch Green Instance
    needs: build
    runs-on: ubuntu-latest
    outputs:
      green_instance_id: ${{ steps.launch.outputs.instance_id }}
      
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Launch single green instance
        id: launch
        run: |
          echo "Launching new green instance..."
          
          INSTANCE_ID=$(aws ec2 run-instances \
            --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }} \
            --count 1 \
            --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
            --tag-specifications "ResourceType=instance,Tags=[
              {Key=Environment,Value=green},
              {Key=Version,Value=${{ needs.build.outputs.image_tag }}},
              {Key=Name,Value=quotes-app-green}
            ]" \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Launched green instance: $INSTANCE_ID"
      
      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids ${{ steps.launch.outputs.instance_id }}
          
          echo "Instance is running. Waiting for initialization to complete..."
          sleep 150  # Wait for user data script to complete
          
          echo "Checking SSM agent status..."
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --instance-information-filter-list "key=InstanceIds,valueSet=${{ steps.launch.outputs.instance_id }}" \
              --query 'InstanceInformationList[0].PingStatus' \
              --output text 2>/dev/null || echo "Offline")
            
            echo "Attempt $i/30 - SSM Agent Status: $STATUS"
            
            if [ "$STATUS" = "Online" ]; then
              echo "‚úÖ SSM agent is online and ready"
              exit 0
            fi
            
            sleep 10
          done
          
          echo "‚ö†Ô∏è SSM agent status check timed out, but continuing..."

  deploy:
    name: Deploy Application to Green
    needs: [build, provision-green]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy via SSM
        run: |
          echo "=== Deploying to green instance ==="
          echo "Instance ID: ${{ needs.provision-green.outputs.green_instance_id }}"
          echo "Image Tag: ${{ needs.build.outputs.image_tag }}"
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ needs.provision-green.outputs.green_instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy quotes app ${{ needs.build.outputs.image_tag }}" \
            --parameters 'commands=[
              "#!/bin/bash",
              "set -e",
              "export APP_DIR=/home/ubuntu/quotes-app",
              "echo \"=== Starting Deployment ===\"",
              "echo \"Working directory: $APP_DIR\"",
              "echo \"User: $(whoami)\"",
              "echo \"Hostname: $(hostname)\"",
              "",
              "# Verify AWS CLI",
              "if ! command -v aws &> /dev/null; then",
              "    echo \"ERROR: AWS CLI not found\"",
              "    echo \"PATH: $PATH\"",
              "    exit 1",
              "fi",
              "echo \"AWS CLI: $(aws --version)\"",
              "",
              "# Verify Docker",
              "if ! command -v docker &> /dev/null; then",
              "    echo \"ERROR: Docker not found\"",
              "    exit 1",
              "fi",
              "echo \"Docker: $(docker --version)\"",
              "",
              "# Verify Docker Compose",
              "if ! command -v docker-compose &> /dev/null; then",
              "    echo \"ERROR: Docker Compose not found\"",
              "    exit 1",
              "fi",
              "echo \"Docker Compose: $(docker-compose --version)\"",
              "",
              "# Navigate to app directory",
              "cd $APP_DIR || exit 1",
              "echo \"Current directory: $(pwd)\"",
              "",
              "# Download files from S3",
              "echo \"Downloading deployment files from S3...\"",
              "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/docker-compose.yml . || { echo \"Failed to download docker-compose.yml\"; exit 1; }",
              "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/nginx-config/ ./nginx-config/ --recursive || { echo \"Failed to download nginx-config\"; exit 1; }",
              "aws s3 cp s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/deployment/ ./deployment/ --recursive || { echo \"Failed to download deployment scripts\"; exit 1; }",
              "",
              "# Make scripts executable",
              "chmod +x deployment/*.sh",
              "",
              "# List downloaded files",
              "echo \"Downloaded files:\"",
              "ls -la",
              "ls -la deployment/",
              "ls -la nginx-config/",
              "",
              "# Run deployment script",
              "echo \"Running deployment script...\"",
              "bash deployment/deploy.sh ${{ secrets.DOCKER_USERNAME }} ${{ needs.build.outputs.image_tag }} ${{ secrets.DOCKER_PASSWORD }} green"
            ]' \
            --timeout-seconds 600 \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          
          # Wait for deployment to complete
          echo "Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ needs.provision-green.outputs.green_instance_id }}" \
            --region ${{ env.AWS_REGION }} || true
          
          # Get execution details
          echo "Fetching deployment results..."
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ needs.provision-green.outputs.green_instance_id }}" \
            --region ${{ env.AWS_REGION }})
          
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          
          echo "Deployment Status: $STATUS"
          
          # Show output
          echo "=== Standard Output ==="
          echo "$RESULT" | jq -r '.StandardOutputContent'
          
          if [ "$STATUS" != "Success" ]; then
            echo ""
            echo "=== Standard Error ==="
            echo "$RESULT" | jq -r '.StandardErrorContent'
            echo ""
            echo "‚ùå Deployment failed!"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ Deployment successful!"

  health-check:
    name: Health Check Green Instance
    needs: [build, provision-green, deploy]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Run health check
        run: |
          echo "=== Running health check ==="
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ needs.provision-green.outputs.green_instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Health check for ${{ needs.build.outputs.image_tag }}" \
            --parameters 'commands=[
              "cd /home/ubuntu/quotes-app",
              "bash deployment/health_check.sh"
            ]' \
            --timeout-seconds 300 \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Health check command ID: $COMMAND_ID"
          
          # Wait for health check
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ needs.provision-green.outputs.green_instance_id }}" \
            --region ${{ env.AWS_REGION }} || true
          
          # Get results
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ needs.provision-green.outputs.green_instance_id }}" \
            --region ${{ env.AWS_REGION }})
          
          STATUS=$(echo "$RESULT" | jq -r '.Status')
          
          echo "Health Check Status: $STATUS"
          echo ""
          echo "=== Health Check Output ==="
          echo "$RESULT" | jq -r '.StandardOutputContent'
          
          if [ "$STATUS" != "Success" ]; then
            echo ""
            echo "=== Health Check Errors ==="
            echo "$RESULT" | jq -r '.StandardErrorContent'
            echo ""
            echo "‚ùå Health check failed!"
            exit 1
          fi
          
          echo ""
          echo "‚úÖ Health check passed!"

  register-green:
    name: Register Green to Load Balancer
    needs: [provision-green, health-check]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Register to green target group
        run: |
          echo "Registering green instance to target group..."
          
          aws elbv2 register-targets \
            --target-group-arn ${{ env.GREEN_TG_ARN }} \
            --targets Id=${{ needs.provision-green.outputs.green_instance_id }}
          
          echo "Waiting for target to be healthy..."
          
          for i in {1..60}; do
            HEALTH=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ env.GREEN_TG_ARN }} \
              --targets Id=${{ needs.provision-green.outputs.green_instance_id }} \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)
            
            echo "Attempt $i/60 - Target Health: $HEALTH"
            
            if [ "$HEALTH" = "healthy" ]; then
              echo "‚úÖ Green instance is healthy in target group!"
              exit 0
            fi
            
            if [ "$HEALTH" = "unhealthy" ]; then
              REASON=$(aws elbv2 describe-target-health \
                --target-group-arn ${{ env.GREEN_TG_ARN }} \
                --targets Id=${{ needs.provision-green.outputs.green_instance_id }} \
                --query 'TargetHealthDescriptions[0].TargetHealth.Reason' \
                --output text)
              echo "Target is unhealthy. Reason: $REASON"
            fi
            
            sleep 10
          done
          
          echo "‚ùå Target failed to become healthy"
          aws elbv2 describe-target-health \
            --target-group-arn ${{ env.GREEN_TG_ARN }} \
            --targets Id=${{ needs.provision-green.outputs.green_instance_id }}
          exit 1

  configure-canary:
    name: Configure 20% Canary Traffic
    needs: [provision-green, register-green]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set 80% Blue / 20% Green traffic split
        run: |
          echo "Configuring traffic split..."
          
          RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --query 'Rules[?IsDefault==`true`].RuleArn' \
            --output text)
          
          echo "Listener Rule ARN: $RULE_ARN"
          
          aws elbv2 modify-rule \
            --rule-arn "$RULE_ARN" \
            --actions Type=forward,ForwardConfig="{
              TargetGroups=[
                {TargetGroupArn=${{ env.BLUE_TG_ARN }},Weight=80},
                {TargetGroupArn=${{ env.GREEN_TG_ARN }},Weight=20}
              ],
              TargetGroupStickinessConfig={Enabled=false}
            }"
          
          echo ""
          echo "‚úÖ Traffic Distribution Configured:"
          echo "   - Blue (current): 80%"
          echo "   - Green (new): 20%"
          echo ""
          echo "üß™ Green instance is now receiving 20% of traffic for testing"
          echo ""
          echo "Next steps:"
          echo "  1. Test the application with 20% traffic"
          echo "  2. Monitor logs and metrics"
          echo "  3. Approve deployment to shift 100% traffic to green"

  approve:
    name: QA Approval Gate
    needs: configure-canary
    runs-on: ubuntu-latest
    environment: production-approval
    
    steps:
      - name: Awaiting approval
        run: |
          echo "‚è∏Ô∏è  Deployment paused for QA testing"
          echo ""
          echo "üìä Current State:"
          echo "   - Blue: 1 instance (80% traffic)"
          echo "   - Green: 1 instance (20% traffic)"
          echo ""
          echo "üîç Testing Instructions:"
          echo "   1. Access the application via ALB"
          echo "   2. Verify functionality with 20% traffic"
          echo "   3. Check logs and metrics"
          echo "   4. Test all critical features"
          echo ""
          echo "‚úÖ Click 'Approve and run' to complete deployment (100% ‚Üí Green)"
          echo "‚ùå Or cancel and rollback if issues are found"

  complete-deployment:
    name: Complete Blue-Green Switch
    needs: [provision-green, approve]
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Shift 100% traffic to green
        run: |
          echo "Shifting 100% traffic to green..."
          
          RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --query 'Rules[?IsDefault==`true`].RuleArn' \
            --output text)
          
          aws elbv2 modify-rule \
            --rule-arn "$RULE_ARN" \
            --actions Type=forward,TargetGroupArn=${{ env.GREEN_TG_ARN }}
          
          echo "‚úÖ 100% traffic now routed to green instance"
      
      - name: Get blue instance ID
        id: blue
        run: |
          BLUE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Environment,Values=blue" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text 2>/dev/null || echo "")
          
          echo "blue_id=$BLUE_ID" >> $GITHUB_OUTPUT
          
          if [ -z "$BLUE_ID" ] || [ "$BLUE_ID" = "None" ]; then
            echo "‚ÑπÔ∏è  No blue instance found (this might be the first deployment)"
          else
            echo "Blue instance to cleanup: $BLUE_ID"
          fi
      
      - name: Deregister and terminate blue instance
        if: steps.blue.outputs.blue_id != '' && steps.blue.outputs.blue_id != 'None'
        run: |
          echo "Deregistering blue instance from target group..."
          
          aws elbv2 deregister-targets \
            --target-group-arn ${{ env.BLUE_TG_ARN }} \
            --targets Id=${{ steps.blue.outputs.blue_id }} || true
          
          echo "Waiting for connection draining (30 seconds)..."
          sleep 30
          
          echo "Terminating old blue instance..."
          aws ec2 terminate-instances --instance-ids ${{ steps.blue.outputs.blue_id }}
          
          echo "‚úÖ Old blue instance terminated"
      
      - name: Promote green to blue
        run: |
          echo "Tagging green instance as new blue..."
          
          aws ec2 create-tags \
            --resources ${{ needs.provision-green.outputs.green_instance_id }} \
            --tags \
              Key=Environment,Value=blue \
              Key=Name,Value=quotes-app-blue
          
          echo ""
          echo "========================================"
          echo "‚úÖ DEPLOYMENT COMPLETE!"
          echo "========================================"
          echo ""
          echo "Summary:"
          echo "  - New instance promoted to blue"
          echo "  - Old blue instance terminated"
          echo "  - 100% traffic on new version"
          echo ""
          echo "üéâ Blue-Green deployment successful!"
